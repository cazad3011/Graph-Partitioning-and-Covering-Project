                          
#                                       CONVEX PARTITIONING AND MAPPING ALGORITHM

# 1 Introduction 
A graph partitioning algorithm divides a problem into two or more subproblems and tries to reduce the interaction between these subproblems. Graph partitioning problem falls under the category of NP-hard problem. In this paper, we are presenting a convex partitioning and mapping algorithm for minimizing cut-size of partitions, for computing and minimizing longest depth of non-convex partitions and for computing longest depth of convex partitions. These problems are NP-hard problems and hence, our convex partitioning and mapping algorithm is a heuristic algorithm to obtain a good solution, or hopefully a near-optimal solution.Convex partitioning and mapping algorithm deals with the task of dividing(partitioning) a given big application graph into two or more parts such that the total number of the edges interconnecting these parts and longest depth of non-convex partitions are minimized while maintaining a given balance constraints among the part size. Convex partitioning and mapping algorithm has many important applications in VLSI design.   
## 1.1 Related Work 
Kernighan-Lin[1] proposed a two-way graph partitioning algorithm which became the basis for most of the subsequent partitioning algorithms, all of which we call the KL-based algorithms. Kernighan-Lin's algorithm (KL algorithm) works only on balanced partitions, and performs number of passes over the cells of the circuit until it finds a locally minimum partition. Each pass consists of a repeated operation of pairwise cell swapping for all pairs of cells. Fiduccia-Mattheyses[2] proposed a faster implementation of KL algorithm. FiducciaMattheyses' algorithm (FM algorithm) can operate on unbalanced partitions provided that the part sizes satisfy a particular balance constraint. They also proposed a single cell move instead of a swap of a cell pair at each step in a pass. These modifications as well as proper data structures, like bucket lists, reduced the time complexity of a single pass of KL algorithm to linear in the size of the circuit (the number of pins). Since real circuits are usually very big, KL algorithm is not very efficient for practical use because of its high time complexity, and so the partitioning algorithms proposed after FM algorithm have utilized all the features of FM algorithm. Sanchis[4] proposed a multiway circuit partitioning algorithm based on Krishnamurthy's[3] algorithm so that it could handle the partitioning of a circuit into more than two parts. All the previous approaches before Sanchis' algorithm (FMS algorithm) are originally bipartitioning algorithms. Our proposed convex partitioning and mapping algorithm for graph partitioning is based on FMS algorithm and convexity of graph. Our actual problem is to partition a given application or big graph according to the size of a small resource graph such that each partition is covered by the resource graph. In FMS algorithm, balance criterion of size of partitions state that size of each partition should be in a close integral range. But, we have adopted the balance criterion that allows the size of each partition within interval [0, n‚Äô], where n‚Äô is total number of nodes present in resource graph R(V‚Äô, E‚Äô). 

# 2 Basic Definitions and Notations 
A directed graph G(V, E) consists of a finite non-empty set V of vertices (nodes) and a finite non-empty set E of edges. A directed graph G(V, E) has |V|= n nodes and |E|= m edges. We have assumed that each node  ![Vi](https://latex.codecogs.com/gif.latex?V_i), 1 ‚â§ i ‚â§ n, has weight 1 and each edge ![ej](https://latex.codecogs.com/gif.latex?e_j), 1 ‚â§ j ‚â§ m has also weight 1. A edge ej is said to be incident to the node ![Vi](https://latex.codecogs.com/gif.latex?V_i) if ![Vi](https://latex.codecogs.com/gif.latex?V_i) ‚àà ![ej](https://latex.codecogs.com/gif.latex?e_j). If an edge ![ej](https://latex.codecogs.com/gif.latex?e_j) is incident to a node ![Vi](https://latex.codecogs.com/gif.latex?V_i), then we say that ![ej](https://latex.codecogs.com/gif.latex?e_j) is on ![Vi](https://latex.codecogs.com/gif.latex?V_i), or ![Vi](https://latex.codecogs.com/gif.latex?V_i) is on ![ej](https://latex.codecogs.com/gif.latex?e_j). Nodes on an edge are called its terminals, and edges on a node are called its pins. Nodes that share terminals are called neighbor nodes. 
The degree ![di](https://latex.codecogs.com/gif.latex?d_i) of a node ![Vi](https://latex.codecogs.com/gif.latex?V_i) is equal to the number of edges incident to ![Vi](https://latex.codecogs.com/gif.latex?V_i). The maximum node degree ![dmax](https://latex.codecogs.com/gif.latex?d_m_a_x) is the biggest value of node degree among all nodes of set V. The degree |![ej](https://latex.codecogs.com/gif.latex?e_j)| of an edge ![ej](https://latex.codecogs.com/gif.latex?e_j) is equal to the number of its terminals. For graph, each edge has 2 terminals. Thus, for graph, degree |![ej](https://latex.codecogs.com/gif.latex?e_j)| of each edge is 2. The total number p of pins, or the total number of terminals, in G(V, E) is defined as

![First equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%20p%20%3D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%7B%5Cleft%7Ce_j%7C%5Cright%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bd_i%20%7D%3D%202%5Ctimes%20m%7D%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%281%29)
                                                                   
and is taken as the size of the graph. The density D of directed graph G(V, E) with n ‚â• 2 is defined as

![Second equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7BD%3D%5Cfrac%7B%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%7B%20%28%20%5Cleft%7Ce_j%5Cright%7C-1%20%29%20%7D%20%7D%7Bn%5Cleft%20%28%20n-1%20%5Cright%20%29%7D%20%3D%5Cfrac%20%7Bm%7D%7Bn%5Cleft%20%28%20n-1%20%5Cright%20%29%7D%7D%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%282%29)

The density of a graph determines how sparse the graph is, and we say that the smaller the density of a graph, sparser the graph. 
Given a directed graph G(V, E), we say that œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k)) is a k-way partition of G(V, E) if the following three properties hold: each part ![Pi](https://latex.codecogs.com/gif.latex?P_i), 1 ‚â§ i ‚â§ k, is a subset of V, parts are pairwise disjoint, and the union of k parts is equal to V. A k-way partition is also called a multiway partition if k > 2, and a bipartition if k = 2. 
Consider a k-way partition œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k)) of a graph G(V, E). The size w(![Pi](https://latex.codecogs.com/gif.latex?P_i)) of a part ![Pi](https://latex.codecogs.com/gif.latex?P_i) is equal to the total number of nodes in ![Pi](https://latex.codecogs.com/gif.latex?P_i). An edge that has at least one pin in a part is said to connect that part. An edge that connects more than one part is said to be cut, otherwise uncut. The set E(i) of external edges of a part ![Pi](https://latex.codecogs.com/gif.latex?P_i) is defined as E(i) = {![ej](https://latex.codecogs.com/gif.latex?e_j) œµ E | ![ej](https://latex.codecogs.com/gif.latex?e_j) ‚à© ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚â† ‚àÖ ^ ![ej](https://latex.codecogs.com/gif.latex?e_j) - ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚â† ‚àÖ }, which consists of those cut edges that connect ![Pi](https://latex.codecogs.com/gif.latex?P_i). The set I(i) of internal edges of a part ![Pi](https://latex.codecogs.com/gif.latex?P_i) is defined as I(i) = {![ej](https://latex.codecogs.com/gif.latex?e_j) œµ E | ![ej](https://latex.codecogs.com/gif.latex?e_j) ‚à© ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚â† ‚àÖ ^ ![ej](https://latex.codecogs.com/gif.latex?e_j) - ![Pi](https://latex.codecogs.com/gif.latex?P_i) = ‚àÖ }, which consists of those uncut edges that connect only ![Pi](https://latex.codecogs.com/gif.latex?P_i). 
The cost x(ùùÖ) of a partition ùùÖ, also called the cut-size, is equal to the number of cut edges. More formally, x(ùùÖ) = total number of edges connected to partition ùùÖ - total number of internal edges of partition ùùÖ (i.e. I(ùùÖ)). Each cut edge ![ej](https://latex.codecogs.com/gif.latex?e_j) contributes an amount of 1 to the cut-size regardless of the number of parts that ![ej](https://latex.codecogs.com/gif.latex?e_j) connects.  
## 2.1 Concept of Cost, Gain and Cut-size 
The cutstate of an edge indicates whether the edge is cut or uncut. The cutset of a partition is the set of all edges that are cut. Notice that an edge in the cutset must be in the set of external edges of at least two parts. An edge is critical if it has a node such that the node would change the cutstate of the edge if it is moved. Such a move either adds the edge to the cutset or removes the edge from the cutset. We now give the necessary and sufficient condition for an edge to be critical in a k-way partition. 
Proposition 2.1 An edge ej is critical if and only if either there exists a part ![Ps](https://latex.codecogs.com/gif.latex?P_s) such that ![ùúπj](https://latex.codecogs.com/gif.latex?ùúπ_j)(s) =2 or there exist two different parts ![Ps](https://latex.codecogs.com/gif.latex?P_s) and ![Pt](https://latex.codecogs.com/gif.latex?P_t) such that ![ùúπj](https://latex.codecogs.com/gif.latex?ùúπ_j)(s) = 1 and ![ùúπj](https://latex.codecogs.com/gif.latex?ùúπ_j)(t) = 1,  where ![ùúπj](https://latex.codecogs.com/gif.latex?ùúπ_j)(s) and ![ùúπj](https://latex.codecogs.com/gif.latex?ùúπ_j)(t) are the number of terminals of edge ![ej](https://latex.codecogs.com/gif.latex?e_j)  that lie in the partition ![Ps](https://latex.codecogs.com/gif.latex?P_s)  and ![Pt](https://latex.codecogs.com/gif.latex?P_t) respectively. 
The cutstate of an edge that is not critical cannot be affected by a node move by the definition of a critical edge, and so such a move cannot have any effect (a decrease or an increase) on the cut-size. A move of a node can change the cut-size if the node removes some edges from the cutset, or adds some 
edges to the cutset, that is, if it alters the cutstate of some edges, which should then be critical edges. Hence, we proved the following proposition. 
Proposition 2.2 The effect of a move of a node on the cutsize depends only on the critical edges incident to that node. 
We reflect the effect of a node in the cut-size in terms of its gains, but the gains of a node depends on its costs. Let ![Ps](https://latex.codecogs.com/gif.latex?P_s) and ![Pt](https://latex.codecogs.com/gif.latex?P_t) be two parts. The cost ![Ci](https://latex.codecogs.com/gif.latex?C_i) (s, t) of a node ![Vi](https://latex.codecogs.com/gif.latex?V_i) in ![Ps](https://latex.codecogs.com/gif.latex?P_s) with respect to ![Pt](https://latex.codecogs.com/gif.latex?P_t) is called its external cost if s ‚â†t and is defined as 

![Third equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7BC_i%20%28s%2C%20t%29%20%3D%20%7CE_i%20%28s%2C%20t%29%7C%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%283%29)                                                                                                                               

where the set ![Ei](https://latex.codecogs.com/gif.latex?E_i) (s, t) is the subset of external edges of ![Ps](https://latex.codecogs.com/gif.latex?P_s) that would be deleted from the cutset if ![Vi](https://latex.codecogs.com/gif.latex?V_i) is moved from ![Ps](https://latex.codecogs.com/gif.latex?P_s) to ![Ps](https://latex.codecogs.com/gif.latex?P_s). Hence, the external cost ![Ci](https://latex.codecogs.com/gif.latex?C_i) (s, t) of a node ![Vi](https://latex.codecogs.com/gif.latex?V_i) in ![Ps](https://latex.codecogs.com/gif.latex?P_s) with respect to ![Pt](https://latex.codecogs.com/gif.latex?P_t) is equal to the number of edges present in the set ![Ei](https://latex.codecogs.com/gif.latex?E_i) (s, t). The cost ![Ci](https://latex.codecogs.com/gif.latex?C_i) (s, t) of a node ![Vi](https://latex.codecogs.com/gif.latex?V_i) in ![Ps](https://latex.codecogs.com/gif.latex?P_s) is called its internal cost if s = t, and is defined as

![Fourth equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7BC_i%20%28s%2C%20s%29%20%3D%20%7CI_i%20%28s%29%7C%5C%20%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%284%29)                                                                                                             

where the set ![Ii](https://latex.codecogs.com/gif.latex?I_i) (s) is the subset of internal edges of ![Ps](https://latex.codecogs.com/gif.latex?P_s) that would be added to cutset if ![Vi](https://latex.codecogs.com/gif.latex?V_i) is moved from ![Ps](https://latex.codecogs.com/gif.latex?P_s) to any other part. Hence, the internal cost ![Ci](https://latex.codecogs.com/gif.latex?C_i) (s, s) of a node ![Vi](https://latex.codecogs.com/gif.latex?V_i) in ![Ps](https://latex.codecogs.com/gif.latex?P_s) is equal to the number of edges present in the set ![Ii](https://latex.codecogs.com/gif.latex?I_i) (s). Since ![Vi](https://latex.codecogs.com/gif.latex?V_i) can change the cutstate of edges in both ![Ei](https://latex.codecogs.com/gif.latex?E_i) (s, t) and ![Ii](https://latex.codecogs.com/gif.latex?I_i) (s), those edges are all critical edges. In a k-way partition, each node has only one internal cost but (k- 1) external costs, each of which corresponds to a move direction towards remaining (k-1) parts. 
The move gain (or gain) ![Gi](https://latex.codecogs.com/gif.latex?G_i) (s, t) of a node ![Vi](https://latex.codecogs.com/gif.latex?V_i) in ![Ps](https://latex.codecogs.com/gif.latex?P_s) with respect to ![Pt](https://latex.codecogs.com/gif.latex?P_t), i.e., the gain of the move of ![Vi](https://latex.codecogs.com/gif.latex?V_i) from ![Ps](https://latex.codecogs.com/gif.latex?P_s) to ![Pt](https://latex.codecogs.com/gif.latex?P_t), is defined as

![Fifth equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7BG_i%20%28s%2C%20t%29%20%3D%20C_i%28s%2Ct%29-C_i%28s%2Cs%29%5C%20%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%285%29)

where s ‚â† t. Note that each node has ( k ‚Äì 1) move gains in a k-way partition. The maximum move gain is denoted by ![Gmax](https://latex.codecogs.com/gif.latex?G_m_a_x), and is equal to the product of the maximum node degree and the maximum edge weight. i.e. ![Gmax](https://latex.codecogs.com/gif.latex?G_m_a_x) = ![dmax](https://latex.codecogs.com/gif.latex?d_m_a_x) √ó 1 = ![dmax](https://latex.codecogs.com/gif.latex?d_m_a_x) , where maximum edge weight =1. 
All the gains fall in the interval [-![Gmax](https://latex.codecogs.com/gif.latex?G_m_a_x) , ![Gmax](https://latex.codecogs.com/gif.latex?G_m_a_x) ]. 
Proposition 2.3 Consider the move of node from ![Ps](https://latex.codecogs.com/gif.latex?P_s) to ![Pt](https://latex.codecogs.com/gif.latex?P_t). Let the cut-size before and after the move be denoted by x(ùùÖ) and x'(ùùÖ), respectively. Then

![sixth equaltion](https://latex.codecogs.com/gif.latex?%5Cmathbf%7Bx%27%20%28%5Camalg%20%29%20%3D%20x%20%28%5Camalg%20%29-G_i%28s%2Ct%29%5C%20%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%286%29)

where ![Gi](https://latex.codecogs.com/gif.latex?G_i) (s, t) is the move gain of ![Vi](https://latex.codecogs.com/gif.latex?V_i) before the move. 
As this proposition shows, the gain of a node determines the amount of benefit to be obtained by moving that node. If the gain is positive, the cut-size decreases, but if the gain is negative, it increases. 
## 2.2 Concept of convex and non-convex partition 
A partition ![Pcp](https://latex.codecogs.com/gif.latex?P_c_p) ‚àà œÄ is said to be a convex partition if and only if for each path ![pAB](https://latex.codecogs.com/gif.latex?p_A_B) between node A ‚àà ![Pcp](https://latex.codecogs.com/gif.latex?P_c_p) and node B ‚àà ![Pcp](https://latex.codecogs.com/gif.latex?P_c_p) , there exist a node C ‚àà ![pAB](https://latex.codecogs.com/gif.latex?p_A_B) then C ‚àà ![Pcp](https://latex.codecogs.com/gif.latex?P_c_p), where A ‚â† B, C ‚â† A and C ‚â† B. If a partition ![Pncp](https://latex.codecogs.com/gif.latex?P_n_c_p) ‚àà œÄ doesn‚Äôt follow above condition then the partition ![Pncp](https://latex.codecogs.com/gif.latex?P_n_c_p) is known as non-convex partition. The union of all convex partitions is represented as convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) and the union of all non-convex partitions is represented as non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) . Thus, we can say that union of set ![Pc](https://latex.codecogs.com/gif.latex?P_c) and set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) represents the partition set œÄ which is given as

![Seventh equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7BP_c%5Ccup%20P_n_c%20%3D%5Camalg%5C%20%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%287%29)
## 2.3 Concept of Input and Output node 
The input node ![vip](https://latex.codecogs.com/gif.latex?v_i_p) of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) is a node which has either no incoming edge or if an edge ![eip](https://latex.codecogs.com/gif.latex?e_i_p) ‚àà E is incoming on ![vip](https://latex.codecogs.com/gif.latex?v_i_p) then there doesn‚Äôt exist a node ![vt](https://latex.codecogs.com/gif.latex?v_t) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) for which ![eip](https://latex.codecogs.com/gif.latex?e_i_p) is outgoing edge. Similarly, the output node vop of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) is a node which has either no outgoing edge or if an edge ![eop](https://latex.codecogs.com/gif.latex?e_o_p) ‚àà E is outgoing from ![vop](https://latex.codecogs.com/gif.latex?v_o_p) then there doesn‚Äôt exist a node ![vt](https://latex.codecogs.com/gif.latex?v_t) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) for which ![eop](https://latex.codecogs.com/gif.latex?e_o_p) is incoming edge. Union of all input nodes of partition set œÄ is represented as input set ![vi](https://latex.codecogs.com/gif.latex?v_i) ‚àà V and union of all output nodes of  œÄ is represented as output set ![vo](https://latex.codecogs.com/gif.latex?v_o) ‚àà V. 
We now define the graph covering problem as follows.                  
Given a big directed graph G(V, E) or application graph and a small directed graph R(V‚Äô, E‚Äô) or resource graph, we initially produce a k-way partition set œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢,![Pk](https://latex.codecogs.com/gif.latex?P_k) as the initial solution in which the size w(![Pi](https://latex.codecogs.com/gif.latex?P_i)) of each part ![Pi](https://latex.codecogs.com/gif.latex?P_i), 1 ‚â§ i ‚â§ k, satisfies the balancing constraint L(![Pi](https://latex.codecogs.com/gif.latex?P_i)) ‚â§ w(![Pi](https://latex.codecogs.com/gif.latex?P_i)) ‚â§ U(![Pi](https://latex.codecogs.com/gif.latex?P_i)). Here, L(![Pi](https://latex.codecogs.com/gif.latex?P_i)) and U(![Pi](https://latex.codecogs.com/gif.latex?P_i)) are integral lower and upper bounds of size of ![Pi](https://latex.codecogs.com/gif.latex?P_i), respectively. Then we minimize cut-size of partition set œÄ as well as longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) of non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) ‚àà ùùÖ while maintaining the balancing constraints. All three problems, the multiway graph partitioning problem, convexity detection problem and longest path problem fall under the category of NP-hard problem. 
We say that a partition is acceptable if it satisfies the given balance criterion as well as longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) of non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) ‚àà ùùÖ ‚â§ longest depth ![Lc](https://latex.codecogs.com/gif.latex?L_c) of convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) ‚àà ùùÖ and unacceptable otherwise.  A partition is said to be balanced if the part sizes are in interval [0, n‚Äô], and unbalanced otherwise. A partition in which the part sizes are the same as the size of resource graph n‚Äô is called a perfectly balanced partition, but such partition is difficult in some cases because value of n mod n‚Äô may not be 0 and it also depends upon initial random partitioning.

# 3 Description of Strategy and Algorithm  
In this section, we discuss about our proposed algorithms and strategies for graph partitioning, convexity detection and longest depth of partition set  ùùÖ of G(V, E). 
## 3.1 Strategy 
There are two subproblems in the graph partitioning and covering problem. First deals graph partitioning while second deals with convexity detection and longest depth of partition set ùùÖ . We are using the following strategies for graph covering, convexity detection and for longest depth of partition set ùùÖ of G(V, E). 
1. Create a random initial k-way partition set œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k)) of the initial graph G(V, E) while maintaining the balancing constraints of each partition ![Pi](https://latex.codecogs.com/gif.latex?P_i)  i.e. L(![Pi](https://latex.codecogs.com/gif.latex?P_i)) ‚â§ w(![Pi](https://latex.codecogs.com/gif.latex?P_i)) ‚â§ U(![Pi](https://latex.codecogs.com/gif.latex?P_i)) , 1 ‚â§ i ‚â§ k.
2. Start with an initial partition set œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k)). Calculate the initial cost of each node and assume the final cut-size of graph G(V, E) is equal to the initial cut-size. 
3. At each iteration during a pass, consider all possible moves of each unlock node from its home partition to any of the other (k ‚Äì 1) partitions and choose the best such move according to the maximum move gain while maintaining the balancing constraints of size of partition. Update the node cost and move gain of all affected nodes. Perform passes until no improvement in cutsize size is obtained. 
4. For each i, i=1 to k, calculate the every path p between input node ![vi](https://latex.codecogs.com/gif.latex?v_i) ‚àà V and output node ![vo](https://latex.codecogs.com/gif.latex?v_o) ‚àà V of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) . Check if any node of path p belongs to ![Pt](https://latex.codecogs.com/gif.latex?P_t) where ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚â† ![Pt](https://latex.codecogs.com/gif.latex?P_t) . If such node is found then add the partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) to non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) ‚àà œÄ else convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) ‚àà œÄ. Choose the longest depth ![Li](https://latex.codecogs.com/gif.latex?L_i) among every path p of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i). 
5. Choose the longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) of non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) among the longest depth ![Li](https://latex.codecogs.com/gif.latex?L_i) of each partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚àà ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) , 1 ‚â§ i ‚â§ k. Choose the longest depth ![Lc](https://latex.codecogs.com/gif.latex?L_c) of convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) among the longest depth ![Li](https://latex.codecogs.com/gif.latex?L_i) of each partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚àà ![Pc](https://latex.codecogs.com/gif.latex?P_c) , 1 ‚â§ i ‚â§ k. 
6. Increment the value of iteration itr by 1. 
7. Repeat the step 1, step 2, step 3, step 4, step 5 and step 6 until itr becomes maximum or ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) ‚â§ ![Lc](https://latex.codecogs.com/gif.latex?L_c) .
 
## 3.1 A k-way Graph Partitioning 
In k-way graph partitioning method, we start with a random initial partition set œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k)) and calculate the initial cost of each node of G(V, E). At each step during a pass we consider all possible moves of each node from its source part to any of the other parts in the partition and choose the best such move i.e. the one with the maximum move gain. The selected node is then moved to the target part and is locked for rest of the pass. The node gains of all the affected neighbors are updated accordingly. The next node is chosen in the same way from all the remaining unlocked nodes and is moved to its target part. The node move process is repeated until all the nodes are locked or there are no legal moves available due to the balance constraint. Now maximum gain sum ![Sb](https://latex.codecogs.com/gif.latex?S_b) of the selected b nodes is calculated and if ![Sb](https://latex.codecogs.com/gif.latex?S_b) is found positive then we make the first b nodes move permanent and improve the cut-size by decreasing it by ![Sb](https://latex.codecogs.com/gif.latex?S_b). Maximum gain sum ![Sb](https://latex.codecogs.com/gif.latex?S_b) defines the effect on cut-size after moving first b selected nodes permanently. ![Sb](https://latex.codecogs.com/gif.latex?S_b) is equal to the sum of move gains of first b selected nodes. All the nodes moved after the bth node move is reversed to the original part so that the actually moved nodes are the sequence of moving first node from part ![a1](https://latex.codecogs.com/gif.latex?a_1) to part ![b1](https://latex.codecogs.com/gif.latex?b_1), second node from ![a2](https://latex.codecogs.com/gif.latex?a_2) to ![b2](https://latex.codecogs.com/gif.latex?b_2) ,‚Ä¶, the ![bth](https://latex.codecogs.com/gif.latex?b_t_h) node from ![ab](https://latex.codecogs.com/gif.latex?a_b) to ![bb](https://latex.codecogs.com/gif.latex?b_b) , where ![a1](https://latex.codecogs.com/gif.latex?a_1),![a2](https://latex.codecogs.com/gif.latex?a_2)....![ab](https://latex.codecogs.com/gif.latex?a_b),![b1](https://latex.codecogs.com/gif.latex?b_1),![b2](https://latex.codecogs.com/gif.latex?b_2),....![bb](https://latex.codecogs.com/gif.latex?b_b) ‚àà œÄ = (![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k)), k is the number of parts. The whole process is called a pass. Several passes are performed until ![Sb](https://latex.codecogs.com/gif.latex?S_b) is no longer positive. Then we say that the local optimum with respect to the initial random solution is obtained. The move that do not violate the balance criterion are called legal moves, otherwise illegal. In this method, only legal moves are considered for a move. In k-way partitioning algorithms, each node has (k-1) possible move directions at each step in a pass where each move direction corresponds to a move from its source part to each of the other parts of partition set œÄ. There are k(k-1) possible move directions in total as only the best move is considered in each move direction. An array of pointers, is called bucket array [4], is used for storing move gain for all possible moves. Bucket array is used to keep track of move gain of nodes 
with respect to their move direction. Since a bucket array stores move gain of all possible moves which fall in interval [-![Gmax](https://latex.codecogs.com/gif.latex?G_m_a_x) , ![Gmax](https://latex.codecogs.com/gif.latex?G_m_a_x) ].Thus size of bucket array is defined as 

![Eight equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%20bucketsize%20%3D2%5Ctimes%20G_m_a_x%20&plus;%201%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%288%29)
### 3.1.1 Initial_Partition Algorithm
We use Initial_Partition algorithm to produce a random initial k-way partition set œÄ=(![P1](https://latex.codecogs.com/gif.latex?P_1), ‚Ä¢ ‚Ä¢ ‚Ä¢ , ![Pk](https://latex.codecogs.com/gif.latex?P_k) of graph G, where k is the number of parts of partition set œÄ. This algorithm maintains the balancing constraints of each part ![Pi](https://latex.codecogs.com/gif.latex?P_i) , 1 ‚â§ i ‚â§ k,  i.e. L(![Pi](https://latex.codecogs.com/gif.latex?P_i)) ‚â§ w(![Pi](https://latex.codecogs.com/gif.latex?P_i)) ‚â§ U (![Pi](https://latex.codecogs.com/gif.latex?P_i)), where L(![Pi](https://latex.codecogs.com/gif.latex?P_i)) and U(![Pi](https://latex.codecogs.com/gif.latex?P_i))  are lower and upper bound of size w(![Pi](https://latex.codecogs.com/gif.latex?P_i)) of part ![Pi](https://latex.codecogs.com/gif.latex?P_i). We take upper bound U(![Pi](https://latex.codecogs.com/gif.latex?P_i)) = n‚Äô, where n‚Äô =|V‚Äô| and lower bound L(![Pi](https://latex.codecogs.com/gif.latex?P_i)) = 0, because each partition should be covered by the resource graph R(V‚Äô, E‚Äô).The value of k is calculated according to the resource graph R(V‚Äô,E‚Äô) and application graph G(V,E) and given by

![Ninth equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%20Number%5C%20of%20%5C%20parts%20%28k%29%20%3D%20n/n%27%20&plus;%201%20%2C%20where%20%5C%20%5C%20n%3D%20%7C%20V%20%7C%20%5C%20and%5C%20n%27%20%3D%20%7C%20V%27%20%7C%20%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%289%29) 

We add 1 to n/n‚Äô because if n mod n‚Äô=0, then initial random partitioning creates k parts and each part contains n/n‚Äô nodes which is U(![Pi](https://latex.codecogs.com/gif.latex?P_i)) of part ![Pi](https://latex.codecogs.com/gif.latex?P_i). Now if we try to move one node from one partition to another partition to minimize the cut-edges then it is not possible because balance criterion of partition ùùÖ  is not be satisfied. However, addition of 1 to n/n‚Äô doesn‚Äôt affect the partitioning when n mod n‚Äô ‚â† 0. The initial partition set œÄ produced by this algorithm is used in Graph_Covering Algorithm for optimization of cut-size and longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c). 
## 3.2 Convexity and longest depth  
Non-convexity of a partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) increases the inter-connecting edges between ![Pi](https://latex.codecogs.com/gif.latex?P_i) and other partitions and it also increases the longest path or critical path of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i). In VLSI circuit design, critical path of partition is a major problem because it increases the cost of circuit design. Minimization of cut-size decreases the number of non-convex parts but critical path remains an issue for circuit designing. After obtaining a local optimum value of cut-size, we try to minimize the longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) of non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) using Longest_Depth, Init_Dfs and Dfs algorithms.  
### 3.2.1 Longest_Depth Algorithm 
We calculate the longest depth of each partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚àà  œÄ using this algorithm. We use a flag to determine whether ![Pi](https://latex.codecogs.com/gif.latex?P_i) is convex or non-convex partition. The value of flag is set when partition is non-convex and it is set by Dfs algorithm. At first, we calculate the local longest depth between every input node ![vi](https://latex.codecogs.com/gif.latex?v_i) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) and every output node ![vo](https://latex.codecogs.com/gif.latex?v_o) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) ‚àà ùùÖ using Init_Dfs and Dfs algorithm. From all local longest depth of ![Pi](https://latex.codecogs.com/gif.latex?P_i), we choose a local longest depth with maximum value, is called longest depth ![Li](https://latex.codecogs.com/gif.latex?L_i) of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i). If the value of flag is set then ![Pi](https://latex.codecogs.com/gif.latex?P_i) is added to non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) otherwise ![Pi](https://latex.codecogs.com/gif.latex?P_i) is added to convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) . This process is repeated for all k partitions. Now, we choose the maximum longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) among all partitions of ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c), is called longest depth of non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) . Similarly, we choose a maximum longest depth ![Lc](https://latex.codecogs.com/gif.latex?L_c) and a minimum longest depth ![Lmc](https://latex.codecogs.com/gif.latex?L_m_c) among all partitions of ![Pc](https://latex.codecogs.com/gif.latex?P_c), are called longest depth and minimum longest depth of convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) respectively. The number of all partitions for which flag is set, is called total number of non-convex partitions, is denoted by ![Nncp](https://latex.codecogs.com/gif.latex?N_n_c_p) and defined as 

![Tenth equation](https://latex.codecogs.com/gif.latex?%5Cmathbf%7B%20N_n_c_p%20%3D%20%7C%20P_n_c%7C%20%7D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%2810%29)
### 3.2.2 Init_Dfs and Dfs Algorithm      
Init_Dfs algorithm is used to initialize the data structures of Dfs algorithms. It creates two temporary arrays, first is, visited array to determine whether a node has been visited before or not and second is, path array to store all nodes of the path between an input node ![vi](https://latex.codecogs.com/gif.latex?v_i) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) and an output node ![vo](https://latex.codecogs.com/gif.latex?v_o) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) of partition ![Pi](https://latex.codecogs.com/gif.latex?P_i). Initially, all nodes are marked as unvisited. 
Dfs algorithm is like standard DFS algorithm except some differences. It checks all possible path between an input node ![vi](https://latex.codecogs.com/gif.latex?v_i) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i) and an output node ![vo](https://latex.codecogs.com/gif.latex?v_o) ‚àà ![Pi](https://latex.codecogs.com/gif.latex?P_i). For each path p between ![vi](https://latex.codecogs.com/gif.latex?v_i) and ![vo](https://latex.codecogs.com/gif.latex?v_o) , all nodes in path array  are examined that whether node belongs to partition ![Pi](https://latex.codecogs.com/gif.latex?P_i) or not. If any node of any path between ![vi](https://latex.codecogs.com/gif.latex?v_i) and ![vo](https://latex.codecogs.com/gif.latex?v_o) doesn‚Äôt belongs to ![Pi](https://latex.codecogs.com/gif.latex?P_i) then flag is set. A path p with maximum length is selected, is called local longest depth and it is returned to Longest_Depth algorithm. 
## 3.3 Convex Partitioning And Mapping Algorithm 
This is our main algorithm which uses the functionalities provided by all the above algorithms. This algorithm does recursively partitioning to minimize the longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c). We have assumed the maximum iterations for recursive partitioning is 40. We can‚Äôt allow recursive partitioning more than maximum iterations because it increases the time complexity. However, it is practically observed that number of iterations itr lies in interval [1, 15] for most of the graphs. At the starting, a random seed is created and set. An initial k-way partition set œÄ is obtained by using Initial_Partition algorithm. Then the cut-size of initial partition set is minimized by performing several passes on the initial partition set œÄ and it continues until no improvement in cut-size size is obtained. When a local optimum partition set in term of cut-size is obtained, the longest depth ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) of non-convex partition set ![Pnc](https://latex.codecogs.com/gif.latex?P_n_c) and longest depth ![Lc](https://latex.codecogs.com/gif.latex?L_c) of convex partition set ![Pc](https://latex.codecogs.com/gif.latex?P_c) is computed by using Longest_Depth, Init_Dfs and Dfs algorithms and a comparison between ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) and ![Lc](https://latex.codecogs.com/gif.latex?L_c) is made. Either if ![Lnc](https://latex.codecogs.com/gif.latex?L_n_c) is less than or equal to ![Lc](https://latex.codecogs.com/gif.latex?L_c) or itr is greater than maximum iteration then the algorithm produces output and stops otherwise recursive partitioning continues. 

# 4 Data Structure of Algorithm 
This section describes the main data structures used by the algorithms. 
The below information of node is used by our proposed algorithm. All other data structures are like to the data structure of [4] because we are using k-way partitioning. 
## 4.1 Node Data Structure  
1. A list for the incoming edges of the node.  
2. The partition to which the node currently belongs.  
3. A flag for indicating that whether the node is unlocked or locked.  
4. If the node is unlocked, a bucket array which points (k-1) move gains associated with each of the (k-1) move directions.  
5. If the node is unlocked, the gain values of node associated with (k-1) move directions. 
6. A visited array to determine whether a node has been visited before or not. 
7. A path array to store all nodes of the path between input and output nodes of partition.

# 5 Future Works 
We have computed the longest depth between input node and output node using DFS algorithm. The time complexity may decrease if we use dynamic programming techniques with Dfs algorithm. But it requires extra space of O(n^2) when implementation is done using adjacency matrix. We tried to implement dynamic programming techniques using adjacency matrix representation of graph, we observe that there is a reduction in time complexity for small graphs. But when we use this technique for very big graphs like 20,000 nodes graph, this became infeasible because of memory requirements. So, implementation of dynamic programming may work fine if it is used with adjacency list representation of the graph. One other modification can be suggested as if Dijkstra algorithm is used instead of DFS algorithm then it may give better results for dense graph but it also increases the space complexity and can‚Äôt be used for a graph with edge cycle. For sparse graph, Dijkstra algorithm may not give a better result than DFS algorithm. 

# 6 References 
```
[1] B.W. Kernighan and S. Lin, " An Efficient Heuristic Procedure for Partitioning Graphs", Bell Systems Technical Journal 49, (February 1970), 291-307. 
[2] CM. Fiduccia and R.M. Mattheyses, " A Linear-time Heuristic for Improving Network Partitions", Proc. 19th Design Automation Conference, , 1982, 175-18l. 
[3] B. Krishnamurthy, " An Improved Min-Cut Algorithm for Partitioning VLSI Networks", IEEE Transactions on Computers 33, (May 1984), 438-446. 
[4] L. A. Sanchis, ‚ÄúMultiple-way network partitioning,‚Äù IEEE Trans. Comput., vol. 38, no. 1, pp. 62‚Äì81, Jan. 1989. 
[5] Ali Dasdan and Cevdet Aykanat, ‚ÄúTwo Novel Multiway Circuit Partitioning Algorithms Using Relaxed Locking‚Äù, IEEE Transactions On Computer-Aided Design Of Integrated Circuits And Systems, Vol. 16, No. 2, February 1997. 
[6] Bruce Hendrickson And Robert Leland, ‚ÄúA Multilevel Algorithm For Partitioning Graphs‚Äù, Sandia National Laboratories, Albuquerque, Nm  87185-1110 
[7] S.R. Canoy and I.J.L. Garces, ‚ÄúConvex sets under some graph operations, Graphs and Combinatorics‚Äù, 18 (4) (2002), 787-793.  
[8] M. Changat, H.M. Mulder and G. Sierksma, ‚ÄúConvexities related to path properties on graphs; a uniÔ¨Åed approach‚Äù, Working paper, survey. 
[9] M. Farber and R.E. Jamison, ‚ÄúConvexity in graphs and hypergraphs‚Äù, SIAM J. Alg. Disc. Math. 7 (3) (1986), 433-444. 
[10] Ellis Horowitz, Sartaj Sahni and Sanguthevar Rajasekaran ,‚ÄùFundamentals of Computer Algorithms‚Äù, Universities Press(India) Private Limited.
```  
